
#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba32f) uniform image2D postProcessImage;
layout (set = 0, binding = 1, rgba32f) uniform image2D positionImage;

layout (set = 1, binding = 0) readonly buffer myParams {
 float strength;
 int samples; //ao sample count //64.0
 float radius; //ao radius //5.0

} ssaoData;

//------------------------------------------
//general stuff
 float zNear = 0.1;
 float zFar = 128.0;
//user variables

float aoclamp = 0.125; //depth clamp - reduces haloing at screen edges
bool noise = true; //use noise instead of pattern for sample dithering
float noiseamount = 0.0002; //dithering amount

float diffarea = 0.3; //self-shadowing reduction
float gdisplace = 0.4; //gauss bell center //0.4

bool mist = false; //use mist?
float miststart = 0.0; //mist start
float mistend = 128.0; //mist end

bool onlyAO = false; //use only ambient occlusion pass?
float lumInfluence = 0.7; //how much luminance affects occlusion

//--------------------------------------------------------
float r_depth = imageLoad(positionImage, ivec2(gl_GlobalInvocationID.xy)).z;
    
vec2 rand(vec2 coord) //generating noise/pattern texture for dithering
{
  
   return vec2(fract(sin(dot(coord.x, 12.9898)) * 43758.5453),fract(sin(dot(coord.y, 78.233)) * 43758.5453));
}

float doMist()
{
  float depth = -zFar * zNear / (r_depth * (zFar - zNear) - zFar);
  return clamp((depth-miststart)/mistend,0.0,1.0);
}

float readDepth(vec2 coord, float z_b)
{
   float z_n = 2.0 * z_b - 1.0;
   return (2.0 * zNear) / (zFar + zNear - z_n * (zFar-zNear));
}

int compareDepthsFar(float depth1, float depth2) {
  float garea = 2.0; //gauss bell width
  float diff = (depth1 - depth2)*100.0; //depth difference (0-100)
  //reduce left bell width to avoid self-shadowing
  if (diff<gdisplace)
  {
    return 0;
  } else {
    return 1;
  }
}

float compareDepths(float depth1, float depth2)
{
  float garea = 2.0; //gauss bell width
  float diff = (depth1 - depth2)*100.0; //depth difference (0-100)
  //reduce left bell width to avoid self-shadowing
  if (diff<gdisplace)
  {
    garea = diffarea;
  }

  float gauss = pow(2.7182,-2.0*(diff-gdisplace)*(diff-gdisplace)/(garea*garea));
  return gauss;
}

float calAO(float depth,float dw, float dh)
{
  float dd = (1.0-depth)*ssaoData.radius;

      float width = imageSize(postProcessImage).x;
    float height = imageSize(postProcessImage).y;

   vec2 vUv = gl_GlobalInvocationID.xy/vec2(width, height);

  float temp = 0.0;
  float temp2 = 0.0;
  float coordw = vUv.x + dw*dd;
  float coordh = vUv.y + dh*dd;
  float coordw2 = vUv.x - dw*dd;
  float coordh2 = vUv.y - dh*dd;

  vec2 coord = vec2(coordw , coordh);
  vec2 coord2 = vec2(coordw2, coordh2);

  float cd = readDepth(coord, depth);
  int far = compareDepthsFar(depth, cd);
  temp = compareDepths(depth, cd);
  //DEPTH EXTRAPOLATION:
  if (far > 0)
  {
    temp2 = compareDepths(readDepth(coord2, depth),depth);
    temp += (1.0-temp)*temp2;
  }

  return temp;
}
#define PI    3.14159265

void main()	{
    vec3 pixelColor = imageLoad(postProcessImage, ivec2(gl_GlobalInvocationID.xy)).rgb;
    vec3 fragPos = imageLoad(positionImage, ivec2(gl_GlobalInvocationID.xy)).xyz;

    float width = imageSize(postProcessImage).x;
    float height = imageSize(postProcessImage).y;
    

   vec2 noise = rand(gl_GlobalInvocationID.xy);
  
  float w = (1.0 / width)/clamp(r_depth,aoclamp,1.0)+(noise.x*(1.0-noise.x));
  float h = (1.0 / height)/clamp(r_depth,aoclamp,1.0)+(noise.y*(1.0-noise.y));

  float pw = 0.0;
  float ph = 0.0;

  float ao = 0.0;

  float dl = PI * (3.0 - sqrt(5.0));
  float dz = 1.0 / float(ssaoData.samples);
  float l = 0.0;
  float z = 1.0 - dz/2.0;

  for (int i = 0; i < ssaoData.samples; i++)
  {
    float r = sqrt(1.0 - z);

    pw = cos(l) * r;
    ph = sin(l) * r;
    ao += calAO(r_depth,pw*w,ph*h);
    z = z - dz;
    l = l + dl;
  }


  ao /= float(ssaoData.samples);
  ao *= ssaoData.strength;
  ao = 1.0-ao;

  if (mist)
  {
    ao = mix(ao, 1.0, doMist());
  }

  /*
  vec3 color = texture2D(bgl_RenderedTexture,texCoord).rgb;
  vec3 lumcoeff = vec3(0.299,0.587,0.114);
  float lum = dot(color.rgb, lumcoeff);
  vec3 luminance = vec3(lum, lum, lum);
  vec3 final = vec3(color*mix(vec3(ao),vec3(1.0),luminance*lumInfluence));//mix(color*ao, white, luminance)
  if (onlyAO)
  {
  final = vec3(mix(vec3(ao),vec3(1.0),luminance*lumInfluence)); //ambient occlusion only
  }
  */
  //vec3 final = vec3(depth/1.0);


    imageStore(postProcessImage, ivec2(gl_GlobalInvocationID.xy), vec4(pixelColor * ao, 1.0));
}