#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba32f) uniform image2D postProcessImage;
layout (set = 0, binding = 1, rgba32f) uniform image2D positionImage;
layout (set = 0, binding = 2, rgba32f) uniform image2D normalImage;
layout (set = 0, binding = 3, rgba32f) uniform image2D materialImage;

layout (set = 1, binding = 0) readonly buffer myParams {
  float maxDistance;// = 30;
  float resolution; // = 0.3;
  float thickness; // = 0.5;
  int   steps; //      = 10;
} ssrData;
//https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html
void main()	{
   
    const vec2 sceneArea = imageSize(postProcessImage);
   
    const vec3 pixelColor = imageLoad(postProcessImage, ivec2(gl_GlobalInvocationID.xy)).rgb;
    const vec4 pixelPos = imageLoad(positionImage, ivec2(gl_GlobalInvocationID.xy));
    const vec3 pixelNormal = imageLoad(normalImage, ivec2(gl_GlobalInvocationID.xy)).xyz;
    const vec3 pixelMaterial = imageLoad(materialImage, ivec2(gl_GlobalInvocationID.xy)).xyz;
    const float p_specular = pixelMaterial.x;
    const float p_shininess = pixelMaterial.y;

    int steps = ssrData.steps;

  vec3 unitPositionFrom = normalize(pixelPos.xyz);
  vec3 pivot            = normalize(reflect(unitPositionFrom, pixelNormal));

  vec4 positionTo = pixelPos;

  vec4 startView = vec4(pixelPos.xyz /*+ (pivot *         0.0)*/, 1.0);
  vec4 endView   = vec4(pixelPos.xyz + (pivot * ssrData.maxDistance), 1.0);

  vec4 startFrag      = startView;
       //startFrag      = lensProjection * startFrag;
      // startFrag.xyz /= startFrag.w;
       startFrag.xy   = startFrag.xy * 0.5 + 0.5;
       startFrag.xy  *= sceneArea;

  vec4 endFrag      = endView;
       //endFrag      = lensProjection * endFrag;
      // endFrag.xyz /= endFrag.w;
       endFrag.xy   = endFrag.xy * 0.5 + 0.5;
       endFrag.xy  *= sceneArea;

  vec2 frag  = startFrag.xy;
      // uv.xy = frag / texSize;

  float deltaX    = endFrag.x - startFrag.x;
  float deltaY    = endFrag.y - startFrag.y;
  float useX      = abs(deltaX) >= abs(deltaY) ? 1.0 : 0.0;
  float delta     = mix(abs(deltaY), abs(deltaX), useX) * clamp(ssrData.resolution, 0.0, 1.0);
  vec2  increment = vec2(deltaX, deltaY) / max(delta, 0.001);

  float search0 = 0;
  float search1 = 0;

  int hit0 = 0;
  int hit1 = 0;

  float viewDistance = startView.y;
  float depth        = ssrData.thickness;

  float i = 0;
  vec4 uv = vec4(0.0);

   if (pixelPos == vec4(0.01, 0.01,0.01, 1.0)) { imageStore(postProcessImage, ivec2(gl_GlobalInvocationID.xy), vec4(pixelColor, 1.0)); return; }


  for (i = 0; i < int(delta); ++i) {
    frag      += increment;
    uv.xy      = frag / sceneArea;
    positionTo = imageLoad(positionImage, ivec2(frag.xy));

    search1 =
      mix
        ( (frag.y - startFrag.y) / deltaY
        , (frag.x - startFrag.x) / deltaX
        , useX
        );

    search1 = clamp(search1, 0.0, 1.0);

    viewDistance = (startView.y * endView.y) / mix(endView.y, startView.y, search1);
    depth        = viewDistance - positionTo.y;

    if (depth > 0 && depth < ssrData.thickness) {
      hit0 = 1;
      break;
    } else {
      search0 = search1;
    }
  }

  search1 = search0 + ((search1 - search0) / 2.0);

  steps *= hit0;

  for (i = 0; i < steps; ++i) {
    frag       = mix(startFrag.xy, endFrag.xy, search1);
    uv.xy      = frag / sceneArea;
    positionTo = imageLoad(positionImage, ivec2(frag.xy));

    viewDistance = (startView.y * endView.y) / mix(endView.y, startView.y, search1);
    depth        = viewDistance - positionTo.y;

    if (depth > 0 && depth < ssrData.thickness) {
      hit1 = 1;
      search1 = search0 + ((search1 - search0) / 2);
    } else {
      float temp = search1;
      search1 = search1 + ((search1 - search0) / 2);
      search0 = temp;
    }
  }

  float visibility =
      hit1
    * positionTo.w
    * ( 1
      - max
         ( dot(-unitPositionFrom, pivot)
         , 0
         )
      )
    * ( 1
      - clamp
          ( depth / ssrData.thickness
          , 0
          , 1
          )
      )
    * ( 1
      - clamp
          (   length(positionTo - pixelPos)
            / ssrData.maxDistance
          , 0
          , 1
          )
      )
    * (uv.x < 0 || uv.x > 1 ? 0 : 1)
    * (uv.y < 0 || uv.y > 1 ? 0 : 1);

  visibility = clamp(visibility, 0, 1);

  uv.ba = vec2(visibility);


    int   size       = 6;
  float separation = 2.0;

  // Removes holes in the UV map.
  if (uv.b <= 0.0) {
          uv    = vec4(0.0);
    float count = 0.0;

    uv.xyz /= count;
  }

  if (uv.b <= 0.0) { imageStore(postProcessImage, ivec2(gl_GlobalInvocationID.xy), vec4(pixelColor, 1.0)); return; }

  float alpha = clamp(uv.b, 0.0, 1.0);

  vec4 resultcol = vec4(mix(vec3(0.0), pixelColor.rgb, alpha), alpha);

  imageStore(postProcessImage, ivec2(gl_GlobalInvocationID.xy), vec4(pixelColor + resultcol.xyz * resultcol.w, 1.0) );
}